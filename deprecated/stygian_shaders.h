// stygian_shaders.h - Shader source strings
// Shaders match StygianType enum values in stygian.h
// Uses std430 with explicit float arrays for C struct alignment

#ifndef STYGIAN_SHADERS_H
#define STYGIAN_SHADERS_H

// ============================================================================
// Vertex Shader - Passes data via flat varyings to reduce fragment SSBO reads
// ============================================================================

static const char *stygian_vert_src =
    "#version 430 core\n"
    "layout(location = 0) in vec2 aPos;\n"
    "\n"
    "// Element struct uses explicit float arrays to match C struct exactly\n"
    "struct Element {\n"
    "    vec4 bounds;\n"          // x,y,w,h - 16 bytes
    "    vec4 color;\n"           // RGBA - 16 bytes
    "    vec4 border_color;\n"    // RGBA - 16 bytes
    "    vec4 radius;\n"          // tl,tr,br,bl - 16 bytes
    "    vec4 uv;\n"              // u0,v0,u1,v1 - 16 bytes
    "    uint texture_id;\n"      // 4 bytes
    "    uint type;\n"            // 4 bytes
    "    uint flags;\n"           // 4 bytes
    "    float z;\n"              // 4 bytes (total 16, aligned)
    "    vec2 shadow_offset;\n"   // 8 bytes
    "    float shadow_blur;\n"    // 4 bytes
    "    float shadow_spread;\n"  // 4 bytes (total 16)
    "    vec4 shadow_color;\n"    // 16 bytes
    "    vec4 gradient_start;\n"  // 16 bytes
    "    vec4 gradient_end;\n"    // 16 bytes
    "    float hover;\n"          // 4 bytes
    "    float blend;\n"          // 4 bytes
    "    float gradient_angle;\n" // 4 bytes
    "    float blur_radius;\n"    // 4 bytes (total 16)
    "    float glow_intensity;\n" // 4 bytes
    "    uint parent_id;\n"       // 4 bytes
    "    vec2 _pad0;\n"           // 8 bytes (total 16)
    "    vec4 _reserved[4];\n"    // 64 bytes
    "};\n"                        // Total: 256 bytes
    "\n"
    "layout(std430, binding = 0) buffer ElementBuffer {\n"
    "    Element elements[];\n"
    "};\n"
    "\n"
    "uniform vec2 uScreenSize;\n"
    "\n"
    "// Pass element data to fragment shader via flat varyings\n"
    "flat out vec4 vColor;\n"
    "flat out vec4 vBorderColor;\n"
    "flat out vec4 vRadius;\n"
    "flat out vec4 vUV;\n"
    "flat out uint vType;\n"
    "flat out float vBlend;\n"
    "flat out float vHover;\n"
    "out vec2 vLocalPos;\n"
    "out vec2 vSize;\n"
    "\n"
    "void main() {\n"
    "    Element e = elements[gl_InstanceID];\n"
    "    \n"
    "    if ((e.flags & 1u) == 0u) {\n"
    "        gl_Position = vec4(-2.0, -2.0, 0.0, 1.0);\n"
    "        return;\n"
    "    }\n"
    "    \n"
    "    vec2 uv01 = aPos * 0.5 + 0.5;\n"
    "    vec2 size = e.bounds.zw;\n"
    "    vec2 pixelPos = e.bounds.xy + vec2(uv01.x, 1.0 - uv01.y) * size;\n"
    "    vec2 ndc = (pixelPos / uScreenSize) * 2.0 - 1.0;\n"
    "    ndc.y = -ndc.y;\n"
    "    \n"
    "    gl_Position = vec4(ndc, e.z, 1.0);\n"
    "    \n"
    "    // Pass data to fragment via flat varyings (read once per vertex, not "
    "per fragment)\n"
    "    vColor = e.color;\n"
    "    vBorderColor = e.border_color;\n"
    "    vRadius = e.radius;\n"
    "    vUV = e.uv;\n"
    "    vType = e.type;\n"
    "    vBlend = e.blend;\n"
    "    vHover = e.hover;\n"
    "    vLocalPos = uv01 * size;\n"
    "    vSize = size;\n"
    "}\n";

// ============================================================================
// Fragment Shader - Uses flat varyings instead of SSBO reads
// ============================================================================

static const char *stygian_frag_src =
    "#version 430 core\n"
    "flat in vec4 vColor;\n"
    "flat in vec4 vBorderColor;\n"
    "flat in vec4 vRadius;\n"
    "flat in vec4 vUV;\n"
    "flat in uint vType;\n"
    "flat in float vBlend;\n"
    "flat in float vHover;\n"
    "in vec2 vLocalPos;\n"
    "in vec2 vSize;\n"
    "out vec4 fragColor;\n"
    "\n"
    "uniform sampler2D uFontTex;\n"
    "uniform vec2 uAtlasSize;\n"
    "uniform float uPxRange;\n"
    "\n"
    "float sdRoundedBox(vec2 p, vec2 b, vec4 r) {\n"
    "    r.xy = (p.x > 0.0) ? r.xy : r.zw;\n"
    "    r.x = (p.y > 0.0) ? r.x : r.y;\n"
    "    vec2 q = abs(p) - b + r.x;\n"
    "    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n"
    "}\n"
    "\n"
    "float sdBox(vec2 p, vec2 b) {\n"
    "    vec2 d = abs(p) - b;\n"
    "    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n"
    "}\n"
    "\n"
    "float sdCircle(vec2 p, float r) {\n"
    "    return length(p) - r;\n"
    "}\n"
    "\n"
    "float sdSegment(vec2 p, vec2 a, vec2 b) {\n"
    "    vec2 pa = p - a, ba = b - a;\n"
    "    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n"
    "    return length(pa - ba * h);\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    vec2 center = vSize * 0.5;\n"
    "    vec2 p = vLocalPos - center;\n"
    "    vec4 r = vRadius;\n"
    "    uint type = vType;\n"
    "    \n"
    "    vec4 col = vColor;\n"
    "    float d = 1000.0;\n"
    "    float aa = 1.5;\n"
    "    \n"
    "    // Type 0: STYGIAN_RECT - Rounded rectangle\n"
    "    if (type == 0u) {\n"
    "        d = sdRoundedBox(p, center - 1.0, vec4(r.z, r.y, r.w, r.x));\n"
    "        aa = fwidth(d) * 1.5;\n"
    "    }\n"
    "    // Type 1: STYGIAN_RECT_OUTLINE - Rounded rectangle outline\n"
    "    else if (type == 1u) {\n"
    "        float outer = sdRoundedBox(p, center - 1.0, vec4(r.z, r.y, r.w, "
    "r.x));\n"
    "        float inner = sdRoundedBox(p, center - 3.0, vec4(max(0.0, "
    "r.z-2.0), max(0.0, r.y-2.0), max(0.0, r.w-2.0), max(0.0, r.x-2.0)));\n"
    "        d = max(outer, -inner);\n"
    "        aa = fwidth(d) * 1.5;\n"
    "    }\n"
    "    // Type 2: STYGIAN_CIRCLE - Circle\n"
    "    else if (type == 2u) {\n"
    "        d = sdCircle(p, min(center.x, center.y) - 1.0);\n"
    "        aa = fwidth(d) * 1.5;\n"
    "    }\n"
    "    // Type 3: STYGIAN_METABALL_LEFT - Metaball menu (left anchor)\n"
    "    else if (type == 3u) {\n"
    "        d = sdRoundedBox(p, center - 1.0, vec4(r.z, r.y, r.w, r.x));\n"
    "        aa = fwidth(d) * 1.5;\n"
    "    }\n"
    "    // Type 4: STYGIAN_METABALL_RIGHT - Metaball menu (right anchor)\n"
    "    else if (type == 4u) {\n"
    "        d = sdRoundedBox(p, center - 1.0, vec4(r.z, r.y, r.w, r.x));\n"
    "        aa = fwidth(d) * 1.5;\n"
    "    }\n"
    "    // Type 5: STYGIAN_WINDOW_BODY - Window body with gradient border\n"
    "    else if (type == 5u) {\n"
    "        d = sdRoundedBox(p, center, vec4(r.z, r.y, r.w, r.x));\n"
    "        aa = fwidth(d) * 1.5;\n"
    "        float border_t = smoothstep(-6.0, -1.0, d);\n"
    "        vec3 bot_col = vec3(0.06);\n"
    "        float t = clamp((p.y / center.y) * 0.5 + 0.5, 0.0, 1.0);\n"
    "        vec3 border_grad = mix(bot_col, vBorderColor.rgb, t);\n"
    "        col.rgb = mix(col.rgb, border_grad, border_t);\n"
    "    }\n"
    "    // Type 6: STYGIAN_TEXT - MTSDF text\n"
    "    else if (type == 6u) {\n"
    "        vec2 uv_norm = (vLocalPos / vSize);\n"
    "        vec2 uv = mix(vUV.xy, vUV.zw, uv_norm);\n"
    "        vec4 mtsdf = texture(uFontTex, uv);\n"
    "        float sd = max(min(mtsdf.r, mtsdf.g), min(max(mtsdf.r, mtsdf.g), "
    "mtsdf.b));\n"
    "        vec2 unitRange = uPxRange / uAtlasSize;\n"
    "        vec2 screenTexSize = vec2(1.0) / fwidth(uv);\n"
    "        float screenPxRange = max(0.5 * dot(unitRange, screenTexSize), "
    "1.0);\n"
    "        float w = fwidth(sd) * screenPxRange;\n"
    "        float alpha = smoothstep(0.5 - w, 0.5 + w, sd);\n"
    "        fragColor = vec4(col.rgb, alpha * col.a * vBlend);\n"
    "        if (fragColor.a < 0.01) discard;\n"
    "        return;\n"
    "    }\n"
    "    // Type 7: STYGIAN_ICON_CLOSE - Close icon (X)\n"
    "    else if (type == 7u) {\n"
    "        float arm = min(center.x, center.y) * 0.35;\n"
    "        float d1 = sdSegment(p, vec2(-arm, -arm), vec2(arm, arm)) - 1.5;\n"
    "        float d2 = sdSegment(p, vec2(-arm, arm), vec2(arm, -arm)) - 1.5;\n"
    "        d = min(d1, d2);\n"
    "        aa = 1.5;\n"
    "    }\n"
    "    // Type 8: STYGIAN_ICON_MAXIMIZE - Maximize icon (square outline)\n"
    "    else if (type == 8u) {\n"
    "        float box_size = min(center.x, center.y) * 0.4;\n"
    "        float outer = sdBox(p, vec2(box_size));\n"
    "        float inner = sdBox(p, vec2(box_size - 1.5));\n"
    "        d = max(outer, -inner);\n"
    "        aa = 1.5;\n"
    "    }\n"
    "    // Type 9: STYGIAN_ICON_MINIMIZE - Minimize icon (horizontal line)\n"
    "    else if (type == 9u) {\n"
    "        float line_w = center.x * 0.5;\n"
    "        d = sdBox(p, vec2(line_w, 1.0));\n"
    "        aa = 1.5;\n"
    "    }\n"
    "    // Type 10: STYGIAN_TEXTURE - Texture/image\n"
    "    else if (type == 10u) {\n"
    "        vec2 uv = vLocalPos / vSize;\n"
    "        uv.y = 1.0 - uv.y;\n"
    "        fragColor = texture(uFontTex, uv) * col;\n"
    "        return;\n"
    "    }\n"
    "    // Type 11: STYGIAN_SEPARATOR - Separator line\n"
    "    else if (type == 11u) {\n"
    "        d = abs(p.y) - 0.5;\n"
    "        aa = 1.5;\n"
    "    }\n"
    "    else {\n"
    "        // Fallback: simple box\n"
    "        d = sdBox(p, center - 1.0);\n"
    "        aa = 1.5;\n"
    "    }\n"
    "    \n"
    "    // Hover effect\n"
    "    if (vHover > 0.0) {\n"
    "        col.rgb = mix(col.rgb, col.rgb * 1.3, vHover);\n"
    "    }\n"
    "    \n"
    "    float alpha = 1.0 - smoothstep(-aa, aa, d);\n"
    "    col.a *= alpha * vBlend;\n"
    "    \n"
    "    if (col.a < 0.01) discard;\n"
    "    fragColor = col;\n"
    "}\n";

#endif // STYGIAN_SHADERS_H
